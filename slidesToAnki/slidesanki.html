<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Slides to Anki Deck Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/krmanik/genanki-js/dist/genanki.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>PDF to Anki Deck Converter<a href="https://github.com/Persie0/StudyTools/tree/main/slidesToAnki#readme"
            target="_blank" class="github-icon github-btn"><i class="fab fa-github"></i></a>
    </h1>
    <div id="drop-area">
        <form class="my-form">
            <p>Upload PDF files using the file dialog or by dragging and dropping them onto the dashed region</p>
            <input type="file" id="file-input" multiple accept="application/pdf">
            <label for="file-input" class="button">Select PDF files</label>
        </form>
    </div>
    <div id="file-list"></div>
    <button id="clear-files-button" class="button">Clear Selected Files</button>
    <div id="combine-slides">
        <input type="checkbox" id="combine-checkbox" checked>
        <label for="combine-checkbox">Combine slides with the same title into one card</label>
    </div>
    <div id="combine-similar">
        <input type="checkbox" id="combine-similar-checkbox">
        <label for="combine-similar-checkbox">Combine slides with similar titles (current title starts with previous
            title, or previous title followed by ':')</label>
    </div>
    <div id="remove-incremental">
        <input type="checkbox" id="remove-incremental-checkbox" checked>
        <label for="remove-incremental-checkbox">Remove incremental slides</label>
    </div>
    <div id="include-text">
        <input type="checkbox" id="include-text-checkbox" checked>
        <label for="include-text-checkbox">Include page text as back field (to make images searchable)</label>
    </div>
    <button id="generate-button" disabled>Generate Anki Decks</button>
    <div id="progress-area"></div>
    <div id="reposition-info" class="info-box">
        <h3>In case the card order is not right:</h3>
        <ol>
            <li>Open the card browser in Anki.</li>
            <li>Sort the cards by the desired field using the "Sort Field" option.</li>
            <li>Select all the cards you want to reposition (Ctrl + A on Windows or Cmd + A on Mac).</li>
            <li>Right-click and select "Reposition" to assign the current sorted order to the cards.</li>
        </ol>
        <p>This will ensure that new cards are introduced in the order specified by your sort field.</p>
    </div>
    <div id="stats-area"></div>
    <div id="edit-area" style="display: none;">
        <h3>Edit slides:</h3>
        <div id="edit-container" class="edit-container"></div>
    </div>
    <div id="download-area"></div>

    <script>
        // The `initSqlJs` function is globally provided by all of the main dist files if loaded in the browser.
        // We must specify this locateFile function if we are loading a wasm file from anywhere other than the current html page's folder.
        config = {
            locateFile: filename => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${filename}`
        }

        var SQL;
        initSqlJs(config).then(function (sql) {
            //Create the database
            SQL = sql;
        });
        // Set up the necessary libraries
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        // Initialize variables
        let pdfs = [];
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const generateButton = document.getElementById('generate-button');
        const fileList = document.getElementById('file-list');
        const progressArea = document.getElementById('progress-area');
        const statsArea = document.getElementById('stats-area');
        const combineCheckbox = document.getElementById('combine-checkbox');
        const combineSimilarCheckbox = document.getElementById('combine-similar-checkbox');
        const removeIncrementalCheckbox = document.getElementById('remove-incremental-checkbox');
        const includeTextCheckbox = document.getElementById('include-text-checkbox');
        const clearFilesButton = document.getElementById('clear-files-button');
        const editContainer = document.getElementById('edit-container');
        const editArea = document.getElementById('edit-area');
        const downloadArea = document.getElementById('download-area');

        // Event listeners for drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });

        // Handle dropped files
        dropArea.addEventListener('drop', handleDrop, false);

        // Handle selected files
        fileInput.addEventListener('change', handleFiles, false);

        // Handle generate button click
        generateButton.addEventListener('click', generateAnkiDecks, false);

        // Handle clear files button click
        clearFilesButton.addEventListener('click', clearFiles, false);

        // Prevent default drag behaviors
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight() {
            dropArea.classList.add('highlight');
        }

        function unhighlight() {
            dropArea.classList.remove('highlight');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFiles(filesOrEvent) {
            let files;
            if (filesOrEvent instanceof Event) {
                files = filesOrEvent.target.files;
            } else {
                files = filesOrEvent;
            }
            pdfs = [...pdfs, ...Array.from(files)];
            updateFileList();
            generateButton.disabled = pdfs.length === 0;
        }

        function updateFileList() {
            fileList.innerHTML = '<h3>Selected Files:</h3>';
            pdfs.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `
            <span>${file.name}</span>
            <span class="remove-file" data-index="${index}">&#10005;</span>
        `;
                fileList.appendChild(div);
            });

            // Add event listeners to remove buttons
            document.querySelectorAll('.remove-file').forEach(button => {
                button.addEventListener('click', function () {
                    const index = parseInt(this.getAttribute('data-index'));
                    pdfs.splice(index, 1);
                    updateFileList();
                    generateButton.disabled = pdfs.length === 0;
                });
            });
        }

        function clearFiles() {
            pdfs = [];
            updateFileList();
            generateButton.disabled = true;
        }

        function updateProgress(message, percentage) {
            progressArea.innerHTML = `
        <p>${message}</p>
        <div class="progress-bar">
            <span class="progress-bar-fill" style="width: ${percentage}%;"></span>
        </div>
    `;
        }

        function updateStats(deckName, totalCards, cardStats) {
            let statsHTML = `<h3>Stats for ${deckName}</h3>`;
            statsHTML += `<p>Total cards: ${totalCards}</p>`;
            statsHTML += `<h4>Card details:</h4>`;
            statsHTML += `<ul>`;
            for (const [title, imageCount] of cardStats) {
                statsHTML += `<li>${title}: ${imageCount} image${imageCount !== 1 ? 's' : ''}</li>`;
            }
            statsHTML += `</ul>`;
            statsArea.innerHTML += statsHTML;
        }

        async function generateAnkiDecks() {
    updateProgress("Processing PDFs...", 0);
    statsArea.innerHTML = ''; // Clear previous stats
    downloadArea.innerHTML = ''; // Clear previous download links

    for (let i = 0; i < pdfs.length; i++) {
        const pdf = pdfs[i];
        const pdfDoc = await pdfjsLib.getDocument(URL.createObjectURL(pdf)).promise;

        // Create a model with an image field and an order field
        var m = new Model({
            name: "Basic with Image and Order",
            id: "1543634829845", // Changed ID to differentiate from the old model
            flds: [
                { name: "Order" },
                { name: "Front" },
                { name: "Back" },
                { name: "BackContent" },
                { name: "Text" },
            ],
            req: [[0, "all", [0]]],
            tmpls: [
                {
                    name: "Card 1",
                    qfmt: "{{Front}}",
                    afmt: "{{FrontSide}}<hr id=answer>{{Back}}<div class=\"back-content\">{{BackContent}}</div>",
                }
            ],
            css: `
            .card {
                font-family: arial;
                font-size: 20px;
                text-align: center;
                color: black;
                background-color: white;
            }

            .back-content {
                font-size: 16px;
                display: inline-block;
                text-align: left;
                width: 100%;
                max-width: 500px;
                line-height: 1.6;
                margin: 0 auto;
            }

            h2 {
                display: inline;
            }
            `,
        });

        // Create a deck for each PDF
        const deckName = pdf.name.replace(/\.[^/.]+$/, "");
        const deckId = Date.now(); // Use timestamp for consistent, incremental ID
        var d = new Deck(deckId, deckName);

        const notes = [];
        const cardStats = new Map();

        let previousSlideContent = '';
        let previousTitle = '';

        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
            const page = await pdfDoc.getPage(pageNum);
            const textContent = await page.getTextContent();

            // Remove empty texts and non-letter indexes
            var cleanedItems = textContent.items.filter(item => item.str.trim() !== '' && /[a-zA-Z]/.test(item.str));

            // Skip page if only one item left
            if (cleanedItems.length <= 1) {
                continue;
            }

            // Sort items by y-coordinate (topmost first)
            cleanedItems.sort((a, b) => b.transform[5] - a.transform[5]);

            // Fix umlauts, combine title text, and remove title indexes
            let titleText = '';
            const firstTransform = cleanedItems[0]?.transform?.[5];
            let titleParts = 0;
            for (let j = 0; j < cleanedItems.length; j++) {
                const item = cleanedItems[j];
                if (item.transform[5] === firstTransform && item.str.trim() !== '') {
                    titleParts++;
                    const currentChar = item.str.trim().toLowerCase();
                    if (j < cleanedItems.length - 1 && cleanedItems[j + 1].str === '\u0308') {
                        if (currentChar === 'a') titleText += 'ä';
                        else if (currentChar === 'o') titleText += 'ö';
                        else if (currentChar === 'u') titleText += 'ü';
                        else titleText += item.str + cleanedItems[j + 1].str;
                        j += 1; // Skip the combining diaeresis
                    } else {
                        if (currentChar === 'a\u0308') titleText += 'ä';
                        else if (currentChar === 'o\u0308') titleText += 'ö';
                        else if (currentChar === 'u\u0308') titleText += 'ü';
                        else titleText += item.str;
                    }
                } else {
                    break;
                }
            }

            titleText = titleText.replace(" ̈a", 'ä').replace(" ̈o", 'ö').replace(" ̈u", 'ü');

            // Remove title indexes from cleanedItems
            cleanedItems.splice(0, titleParts);

            let header = titleText.trim();

            // If the title is just one letter, take the next line as well
            if (header.length === 1 && cleanedItems.length > 0) {
                header += ' ' + cleanedItems[0].str.trim();
                cleanedItems.splice(0, 1);
            }

            const scale = 2; // Increase scale for higher resolution
            const viewport = page.getViewport({ scale });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport }).promise;

            const imageData = canvas.toDataURL('image/jpeg', 0.9);

            // Check if we should skip this slide (incremental)
            const currentSlideContent = cleanedItems.map(item => item.str).join(' ');
            if (removeIncrementalCheckbox.checked && includesContent(currentSlideContent, previousSlideContent)) {
                continue;
            }
            previousSlideContent = currentSlideContent;

            let noteKey = header;
            if (combineSimilarCheckbox.checked) {
                const words = header.split(' ');
                if (words.length >= 1 && (previousTitle.startsWith(words[0]) || header.startsWith(previousTitle) || header === previousTitle + ':')) {
                    noteKey = previousTitle;
                }
            }

            // Combine slides with the same title or similar titles (if option is enabled)
            if (combineCheckbox.checked || combineSimilarCheckbox.checked) {
                const existingNoteIndex = notes.findIndex(note => note.key === noteKey);
                if (existingNoteIndex !== -1) {
                    // Append the image to the existing note
                    const existingNote = notes[existingNoteIndex];
                    existingNote.imageHtml += `<img src="${imageData}">`;
                    if (includeTextCheckbox.checked) {
                        existingNote.text += `<br>${currentSlideContent}`;
                    }
                    cardStats.set(noteKey, (cardStats.get(noteKey) || 0) + 1);
                } else {
                    // Create a new note
                    notes.push({
                        key: noteKey,
                        order: notes.length + 1, // Add explicit order
                        header: header,
                        imageHtml: `<img src="${imageData}">`,
                        backContent: '',
                        text: includeTextCheckbox.checked ? currentSlideContent : ''
                    });
                    cardStats.set(noteKey, 1);
                }
            } else {
                // Create a separate note for each slide
                const uniqueNoteKey = `${pageNum}_${header}`;
                notes.push({
                    key: uniqueNoteKey,
                    order: notes.length + 1, // Add explicit order
                    header: header,
                    imageHtml: `<img src="${imageData}">`,
                    backContent: '',
                    text: includeTextCheckbox.checked ? currentSlideContent : ''
                });
                cardStats.set(uniqueNoteKey, 1);
            }

            previousTitle = header;

            updateProgress(`Processing PDF ${i + 1} of ${pdfs.length}, page ${pageNum} of ${pdfDoc.numPages}`, (i / pdfs.length + pageNum / pdfDoc.numPages / pdfs.length) * 100);
        }

        // Add all notes to the deck in the order they were created
        for (const { order, header, imageHtml, backContent, text } of notes) {
            d.addNote(m.note([order.toString(), header, imageHtml, backContent, text]));
        }

        updateProgress(`Creating Anki deck for ${deckName}...`, 90 + (i / pdfs.length) * 10);

        // Create a package and add the deck
        var p = new Package();
        p.addDeck(d);

        // Generate the .apkg file
        const apkgArrayBuffer = await p.writeToFile(`${deckName}.apkg`);

        // Create download link
        const blob = new Blob([apkgArrayBuffer], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = `${deckName}.apkg`;
        downloadLink.textContent = `Download ${deckName}.apkg`;
        downloadArea.appendChild(downloadLink);
        downloadArea.appendChild(document.createElement('br'));

        // Update stats
        updateStats(deckName, notes.length, cardStats);
    }

    updateProgress("All Anki decks generated!", 100);
}
        function showSnackbar(msg) {
            var x = document.getElementById("snackbar");
            x.innerHTML = msg;
            x.className = "show";
            setTimeout(function () { x.className = x.className.replace("show", ""); }, 3000);
        }

        function includesContent(currentText, previousText) {
            const currentWords = new Set(currentText.toLowerCase().split(/\s+/));
            const previousWords = new Set(previousText.toLowerCase().split(/\s+/));
            for (let word of previousWords) {
                if (!currentWords.has(word)) {
                    return false;
                }
            }
            return true;
        }

    </script>
</body>

</html>