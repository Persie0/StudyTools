<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered PDF to Anki Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/krmanik/genanki-js/dist/genanki.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression/dist/browser-image-compression.js"></script>

    <link rel="stylesheet" href="gemini-anki.css">
</head>

<body>
    <div id="app-container">
        <h1>AI-Powered PDF to Anki Converter</h1>

        <div class="info-box">
            <p><b>How it works:</b>
            <ol>
                <li>Enter one or more Google AI (Gemini) API Keys (one per line). (You can save these to your browser).</li>
                <li>Upload a single PDF file.</li>
                <li>The app sends your PDF (or its text, per your settings) to Gemini to get a JSON list of grouped slides.</li>
                <li><b>Choose a mode:</b>
                    <ul>
                        <li><b>Default Mode:</b> For each *group*, it sends the text to Gemini again to get a detailed explanation for the "BackContent" field.</li>
                        <li><b>Annotation Mode:</b> For *each slide* in a group, it asks Gemini for a brief annotation *if needed*. This is added below the slide image in the "Back" field.</li>
                    </ul>
                </li>
                <li>It then builds an Anki deck with the slide images and AI explanations.</li>
            </ol>
            </p>
            <p>⚠️ <b>Warning:</b> This tool makes many API calls and may be slow. **Slide-by-slide mode makes significantly MORE calls.**</p>
            <p>✅ <b>New:</b> The tool automatically retries on rate limits or 503 (model overloaded) errors. If all your keys are busy, it will show a **countdown timer** and wait for the soonest one to be available.</p>
        </div>

        <div class="config-section">
            <label for="api-keys-textarea">Gemini API Keys (one per line):</label>
            <textarea id="api-keys-textarea" rows="4" placeholder="Enter one or more Google AI API Keys here, each on a new line..."></textarea>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                 <button id="save-key-button" style="padding: 10px 15px;">Save Keys</button>
                 <button id="clear-key-button" style="padding: 10px 15px; background-color: #dc3545;">Clear Keys</button>
            </div>
            <a href="https://aistudio.google.com/app/apikey" target="_blank" style="display: block; margin-top: 5px;">Get your API key here</a>
        </div>

        <div class="upload-section">
            <div id="drop-area">
                <form class="my-form">
                    <p>Upload a single PDF file by dragging and dropping or clicking below</p>
                    <input type="file" id="file-input" accept="application/pdf">
                    <label for="file-input" class="button">Upload Full PDF</label>
                </form>
            </div>
            <div id="file-list"></div>
        </div>

        <div class="options-section">
            <h3>Options</h3>
            <div class="options-grid">
                <div>
                    <input type="checkbox" id="compress-images-checkbox" checked>
                    <label for="compress-images-checkbox">Compress images</label>
                </div>
                <div>
                    <input type="checkbox" id="auto-crop-checkbox">
                    <label for="auto-crop-checkbox">Auto-crop white borders</label>
                </div>
                <div>
                    <input type="checkbox" id="include-text-checkbox" checked>
                    <label for="include-text-checkbox">Include original slide text (for search)</label>
                </div>
                <div>
                    <label for="max-resolution-input">Max image width (px):</label>
                    <input type="number" id="max-resolution-input" value="1800" min="1" style="width: 100px;">
                </div>
                <div>
                    <label for="max-size-input">Max image size (kB):</label>
                    <input type="number" id="max-size-input" value="400" min="1" style="width: 100px;">
                </div>

                <div style="grid-column: 1 / -1; border-top: 1px solid #eee; padding-top: 15px;">
                    <label for="grouping-model-select"><b>Grouping AI Model:</b></label>
                    <select id="grouping-model-select">
                        <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash Lite (Fast)</option>
                        <option value="gemini-2.5-flash" selected>Gemini 2.5 Flash (Advanced, Stable, Default)</option>
                        <option value="gemini-2.5-pro">Gemini 2.5 Pro (Newest, Slower)</option>
                    </select>
                </div>
                <div style="grid-column: 1 / -1;">
                    <label><b>Grouping Input Method:</b></label>
                    <div style="background-color: #f9f9f9; padding: 10px; border-radius: 4px; border: 1px solid #eee;">
                        <input type="radio" id="input-text" name="grouping-input" value="text">
                        <label for="input-text">Send Extracted Text (Default, Fast)</label>
                        <br>
                        <input type="radio" id="input-file" name="grouping-input" value="file" checked>
                        <label for="input-file">Upload Full PDF (Slower, may be more accurate)</label>
                    </div>
                </div>
                
                <div style="grid-column: 1 / -1; border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
                    <label for="max-parallel-input">Max parallel tasks:</label>
                    <input type="number" id="max-parallel-input" value="10" min="1" style="width: 100px;">
                    <label for="max-parallel-input" style="font-weight: normal; display: inline;">(Limits concurrent AI calls/image renders to save memory)</label>
                </div>
                <div style="grid-column: 1 / -1; border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
                    <input type="checkbox" id="detailed-grouping-checkbox">
                    <label for="detailed-grouping-checkbox"><b>Enable detailed (smaller) slide grouping</b><br>(Creates more cards with fewer slides each. Good for long or dense PDFs.)</label>
                </div>
                <div style="grid-column: 1 / -1; background-color: #fff8e1; padding: 10px; border-radius: 4px; border: 1px solid #ffe082; margin-top: 10px;">
                    <input type="checkbox" id="slide-by-slide-checkbox">
                    <label for="slide-by-slide-checkbox"><b>Slide-by-slide annotation mode</b><br>(Adds explanations *below each slide* if needed, instead of one big explanation. Makes many more API calls.)</label>
                </div>
            </div>
        </div>

        <div class="action-section">
            <button id="generate-button" disabled>Generate Anki Deck</button>
        </div>

        <div id="progress-area"></div>
        <div id="json-error" class="error-message" style="display: none;"></div>
        <div id="download-area"></div>

        <button type="button" class="collapsible">Stats</button>
        <div class="content">
            <div id="stats-area"></div>
        </div>
    </div>

    <script>
        // --- Setup Libraries ---
        config = {
            locateFile: filename => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${filename}`
        }
        var SQL;
        initSqlJs(config).then(function (sql) {
            SQL = sql;
        });
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        // --- Get DOM Elements ---
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const generateButton = document.getElementById('generate-button');
        const fileList = document.getElementById('file-list');
        const progressArea = document.getElementById('progress-area');
        const statsArea = document.getElementById('stats-area');
        const downloadArea = document.getElementById('download-area');
        const apiKeysTextarea = document.getElementById('api-keys-textarea');
        const saveKeyButton = document.getElementById('save-key-button');
        const clearKeyButton = document.getElementById('clear-key-button');
        const jsonError = document.getElementById('json-error');

        // --- Options ---
        const includeTextCheckbox = document.getElementById('include-text-checkbox');
        const compressImagesCheckbox = document.getElementById('compress-images-checkbox');
        const autoCropCheckbox = document.getElementById('auto-crop-checkbox');
        const maxResolutionInput = document.getElementById('max-resolution-input');
        const maxSizeInput = document.getElementById('max-size-input');
        const slideBySlideCheckbox = document.getElementById('slide-by-slide-checkbox');
        const detailedGroupingCheckbox = document.getElementById('detailed-grouping-checkbox');
        const groupingModelSelect = document.getElementById('grouping-model-select');
        const groupingInputText = document.getElementById('input-text');
        const groupingInputFile = document.getElementById('input-file');
        const maxParallelInput = document.getElementById('max-parallel-input');

        // --- State ---
        let pdfFile = null;
        let keyPool = [];

        // --- Event Listeners ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        dropArea.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);
        generateButton.addEventListener('click', generateAnkiDecks, false);
        apiKeysTextarea.addEventListener('input', checkReady);
        saveKeyButton.addEventListener('click', saveApiKeys);
        clearKeyButton.addEventListener('click', clearApiKeys);

        // Add listeners for all options
        [
            compressImagesCheckbox, includeTextCheckbox, slideBySlideCheckbox, 
            maxResolutionInput, maxSizeInput, groupingModelSelect, 
            groupingInputText, groupingInputFile, detailedGroupingCheckbox,
            maxParallelInput, autoCropCheckbox
        ].forEach(el => { 
            el.addEventListener('change', saveOptions);
        });

        // --- Initial Load ---
        loadApiKeys();
        loadOptions();

        // --- Drag and Drop Handlers ---
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        function highlight() { dropArea.classList.add('highlight'); }
        function unhighlight() { dropArea.classList.remove('highlight'); }
        function handleDrop(e) { handleFiles(e.dataTransfer.files); }

        function handleFiles(filesOrEvent) {
            let files;
            if (filesOrEvent instanceof Event) {
                files = filesOrEvent.target.files;
            } else {
                files = filesOrEvent;
            }

            if (files && files.length > 0) {
                pdfFile = files[0];
                updateFileList();
                checkReady();
            }
        }
        function updateFileList() {
            fileList.innerHTML = '<h3>Selected File:</h3>';
            if (pdfFile) {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `
                    <span>${pdfFile.name}</span>
                    <span class"remove-file" style="cursor: pointer; color: red;" onclick="clearFile()">&#10005;</span>
                `;
                fileList.appendChild(div);
            }
        }

        function clearFile() {
            pdfFile = null;
            fileList.innerHTML = '';
            fileInput.value = '';
            checkReady();
        }

        function checkReady() {
            generateButton.disabled = !(pdfFile && apiKeysTextarea.value.trim() !== '');
        }

        // --- API Key Storage Functions ---
        function saveApiKeys() {
            const apiKeys = apiKeysTextarea.value;
            if (apiKeys) {
                localStorage.setItem('geminiAnkiApiKeys', apiKeys);
                alert('API Keys saved to browser storage.');
            } else {
                alert('Please enter at least one API key to save.');
            }
        }

        function clearApiKeys() {
            localStorage.removeItem('geminiAnkiApiKeys');
            apiKeysTextarea.value = '';
            checkReady();
            alert('API Keys cleared from browser storage.');
        }

        function loadApiKeys() {
            const savedKeys = localStorage.getItem('geminiAnkiApiKeys');
            if (savedKeys) {
                apiKeysTextarea.value = savedKeys;
                checkReady();
            }
        }

        // --- Options Storage Functions ---
        function saveOptions() {
            localStorage.setItem('geminiAnkiOptions', JSON.stringify({
                compressImages: compressImagesCheckbox.checked,
                autoCrop: autoCropCheckbox.checked,
                includeText: includeTextCheckbox.checked,
                maxResolution: maxResolutionInput.value,
                maxSize: maxSizeInput.value,
                slideBySlide: slideBySlideCheckbox.checked,
                detailedGrouping: detailedGroupingCheckbox.checked,
                groupingModel: groupingModelSelect.value,
                groupingInput: groupingInputText.checked ? 'text' : 'file',
                maxParallel: maxParallelInput.value
            }));
        }

        function loadOptions() {
            const savedOptions = localStorage.getItem('geminiAnkiOptions');
            if (savedOptions) {
                try {
                    const options = JSON.parse(savedOptions);
                    // Set values, providing defaults for undefined properties
                    compressImagesCheckbox.checked = options.compressImages !== false; // default true
                    autoCropCheckbox.checked = options.autoCrop === true; // default false
                    includeTextCheckbox.checked = options.includeText !== false; // default true
                    slideBySlideCheckbox.checked = options.slideBySlide === true; // default false
                    detailedGroupingCheckbox.checked = options.detailedGrouping !== false; // default true
                    if (options.maxResolution) maxResolutionInput.value = options.maxResolution;
                    if (options.maxSize) maxSizeInput.value = options.maxSize;
                    if (options.groupingModel) groupingModelSelect.value = options.groupingModel;
                    if (options.maxParallel) maxParallelInput.value = options.maxParallel;
                    
                    if (options.groupingInput === 'text') {
                        groupingInputText.checked = true;
                    } else {
                        groupingInputFile.checked = true;
                    }
                } catch (e) {
                    console.error("Failed to load saved options:", e);
                    localStorage.removeItem('geminiAnkiOptions'); // Clear corrupted data
                }
            }
        }
        
        // --- Progress and Error Updates ---
        function updateProgress(message, percentage) {
            let percentValue = percentage;
            if (typeof percentValue === 'undefined') {
                 const progressBarFill = document.querySelector('.progress-bar-fill');
                 percentValue = progressBarFill ? progressBarFill.style.width : '0%';
            }
            
            progressArea.innerHTML = `
                <p>${message}</p>
                <div class="progress-bar">
                    <span class="progress-bar-fill" style="width: ${percentValue};"></span>
                </div>
            `;
        }

        function showError(message) {
            jsonError.textContent = message;
            jsonError.style.display = 'block';
            updateProgress("Error encountered.", 0);
            generateButton.disabled = false;
        }

        // --- Main Anki Generation Logic ---
        async function generateAnkiDecks() {
            generateButton.disabled = true;
            jsonError.style.display = 'none';
            statsArea.innerHTML = '';
            downloadArea.innerHTML = '';
            updateProgress("Starting...", 0);

            if (!pdfFile || !apiKeysTextarea.value.trim()) {
                showError("Please provide both a PDF file and at least one Gemini API Key.");
                return;
            }

            // Initialize the key pool
            const apiKeysString = apiKeysTextarea.value.trim();
            keyPool = apiKeysString.split('\n')
                .filter(k => k.trim() !== '')
                .map(key => ({ key: key.trim(), availableAt: 0 }));

            if (keyPool.length === 0) {
                showError("Please provide at least one valid API Key.");
                return;
            }

            let pdfDoc;

            // Get options
            const groupingModel = groupingModelSelect.value;
            const groupingInput = groupingInputText.checked ? 'text' : 'file';

            try {
                updateProgress("Loading PDF...", 5);
                pdfDoc = await pdfjsLib.getDocument(URL.createObjectURL(pdfFile)).promise;

                let allPagesText = null;
                let pdfDataB64 = null;

                if (groupingInput === 'file') {
                    updateProgress("Reading PDF for upload...", 15);
                    pdfDataB64 = await fileToBase64(pdfFile);
                } else {
                    updateProgress("Extracting text from all pages...", 10);
                    allPagesText = await extractAllText(pdfDoc);
                }

                updateProgress("Asking AI to group and filter slides...", 20);
                const groupingJSON = await callGeminiForGrouping(allPagesText, groupingModel, groupingInput, pdfDataB64);

                if (!groupingJSON || !Array.isArray(groupingJSON)) {
                    showError("AI did not return valid JSON for grouping. Check console for details.");
                    console.error("Invalid JSON response:", groupingJSON);
                    return;
                }

                updateProgress("AI grouping received. Starting deck generation...", 30);
                await createDeckFromConfig(pdfDoc, groupingJSON);

                updateProgress("Anki deck generated!", 100);

            } catch (error) {
                showError(`An error occurred: ${error.message}`);
                console.error(error);
            } finally {
                generateButton.disabled = false;
            }
        }

        /**
         * Extracts text from every page of the PDF.
         */
        async function extractAllText(pdfDoc) {
            let allText = '';
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                allText += `\n\n--- PAGE ${pageNum} ---\n${pageText}\n`;
            }
            return allText;
        }

        // --- Helper function for sleeping ---
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- Countdown Timer ---
        async function showWaitingCountdown(totalWaitMs, baseMessage, percentage) {
            updateProgress(`${baseMessage} Waiting for ${Math.ceil(totalWaitMs / 1000)}s...`, percentage);
            await sleep(totalWaitMs);
        }

        // --- Base64 Helper ---
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    const base64Data = reader.result.split(',')[1];
                    resolve(base64Data);
                };
                reader.onerror = error => reject(error);
            });
        }

        // --- Universal API caller with retry logic ---
        async function callGeminiWithRetry(prompt, generationConfig = null, model = 'gemini-2.5-flash-lite', fileBytesBase64 = null) {
            if (!keyPool || keyPool.length === 0) {
                throw new Error("API Key pool is empty.");
            }

            let retryCount = 0;

            while (true) {
                const now = Date.now();
                
                let keyEntry = null;
                for (const entry of keyPool) {
                    if (now >= entry.availableAt) {
                        keyEntry = entry;
                        break;
                    }
                }
                
                const progressBarFill = document.querySelector('.progress-bar-fill');
                const currentPercentage = progressBarFill ? progressBarFill.style.width : '0%';
                const currentProgressMessage = progressArea.querySelector('p') ? progressArea.querySelector('p').textContent : 'Processing...';

                if (!keyEntry) {
                    const soonestAvailableTime = Math.min(...keyPool.map(k => k.availableAt));
                    const waitMs = (soonestAvailableTime - now) + 1000;
                    
                    console.warn(`All keys busy/rate-limited. Waiting for ${waitMs / 1000}s...`);
                    
                    await showWaitingCountdown(waitMs, `All keys busy. Pausing... (Retry #${retryCount})`, currentPercentage);
                    
                    updateProgress(currentProgressMessage, currentPercentage);
                    continue;
                }

                const apiKey = keyEntry.key;
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

                const parts = [{ text: prompt }];
                if (fileBytesBase64) {
                    parts.push({
                        inlineData: {
                            mimeType: 'application/pdf',
                            data: fileBytesBase64
                        }
                    });
                }
                
                const body = {
                    contents: [{ parts: parts }]
                };

                if (generationConfig) {
                    body.generationConfig = generationConfig;
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts[0]) {
                            return data.candidates[0].content.parts[0].text;
                        } else {
                            throw new Error("Invalid successful response structure from Gemini.");
                        }
                    }

                    const errorBody = await response.json();
                    const errorMessage = errorBody.error ? errorBody.error.message : "Unknown API error";

                    if (response.status === 503 || errorMessage.includes("model is overloaded")) {
                        const waitMs = 15000;
                        keyEntry.availableAt = Date.now() + waitMs;
                        
                        console.warn(`Model is overloaded for key ...${apiKey.slice(-4)}. Retrying after ${waitMs / 1000}s.`);
                        updateProgress(`Model overloaded (Key: ...${apiKey.slice(-4)}). Trying next key... (Retry #${retryCount})`, currentPercentage);
                        await sleep(500);
                        updateProgress(currentProgressMessage, currentPercentage);
                        
                        retryCount++;
                        continue;
                    }

                    if (errorMessage.includes("Quota exceeded") && errorMessage.includes("Please retry in")) {
                        const match = errorMessage.match(/Please retry in ([\d\.]+)s/);
                        
                        if (match && match[1]) {
                            const waitTimeS = parseFloat(match[1]);
                            
                            if (waitTimeS > 300) {
                                throw new Error(`Rate limit retry time (${waitTimeS.toFixed(1)}s) for key ending in ...${apiKey.slice(-4)} exceeds 5 minutes. Aborting. Full error: ${errorMessage}`);
                            }

                            const waitMs = (waitTimeS * 1000) + 1000;
                            keyEntry.availableAt = Date.now() + waitMs; 
                            
                            console.warn(`Gemini rate limit hit for key ...${apiKey.slice(-4)}. Setting cool-down for ${waitTimeS.toFixed(1)}s. Trying next key...`);
                            
                            updateProgress(`Key ...${apiKey.slice(-4)} rate-limited. Trying next key... (Retry #${retryCount})`, currentPercentage);
                            await sleep(500);
                            updateProgress(currentProgressMessage, currentPercentage);
                            
                            retryCount++;
                            continue;
                        }
                    }
                    
                    if (response.status === 400 || response.status === 403) {
                         keyEntry.availableAt = Date.now() + 86400000;
                         console.error(`API Key ...${apiKey.slice(-4)} is invalid or unauthorized. Disabling it for 24h. Error: ${errorMessage}`);
                         updateProgress(`Key ...${apiKey.slice(-4)} is invalid. Trying next... (Retry #${retryCount})`, currentPercentage);
                         await sleep(500);
                         updateProgress(currentProgressMessage, currentPercentage);
                         retryCount++;
                         continue;
                    }

                    throw new Error(`Gemini API error (Key: ...${apiKey.slice(-4)}): ${errorMessage}`);

                } catch (error) {
                    console.error(`Network or fetch error (Key: ...${apiKey.slice(-4)}):`, error);
                    keyEntry.availableAt = Date.now() + 30000;
                    console.warn(`Pausing key ...${apiKey.slice(-4)} for 30s due to network error.`);
                    retryCount++;
                    continue;
                }
            }
        }


        /**
         * First Gemini call: To group slides and remove unwanted ones.
         */
        async function callGeminiForGrouping(allPagesText, model, inputType, pdfDataB64) {
            let prompt;
            let filePayload = null;
            const config = { responseMimeType: "application/json" };
            const useDetailedGrouping = detailedGroupingCheckbox.checked;

            const step1Instruction = useDetailedGrouping
                ? `Step 1: Identify Logical Sections
                - Your goal is to create **small, focused groups**.
                - A group should ideally cover only **one or two key concepts** and be **1-4 slides long**.
                - **Do NOT create large groups** (e.g., 10+ slides).
                - It is better to have many small, specific groups than a few large, general ones.
                - For titles, if creating subtopics of a larger topic, format as "Main Topic: Specific Subtopic".`
                : `Step 1: Identify Logical Sections
                Group pages together that cover a single, distinct topic.`;

                        if (inputType === 'file') {
                                prompt = `
                                Task:
                                Analyze the provided PDF presentation and structure it for Anki card creation.
                
                                ${step1Instruction}

                                Step 2: Filter Only Truly Useless Slides
                                - Only REMOVE slides that are purely administrative or structural and contain NO actual new content.
                                - Examples of slides to remove:
                                    - Main title pages (e.g., "Presentation Title", "By [Author]")
                                    - Section divider slides (e.g., "Part 2: The Next Step")
                                    - "Agenda", "Outline", or "Overview" slides.
                                    - "Learning Objectives" slides.
                                    - "Thank you", "Questions?", or "Contact Information" slides.
                                    - Slides that are blank or have almost no content (e.g., just a title and no body, or a single image).
                                - DO NOT remove any slide that introduces new information, concepts, or explanations, even if it is labeled as a summary, recap, or conclusion, as long as it contains actual new content.
                                - For incremental slides (where one slide builds on the previous one), identify the *final* slide in that sequence and include ONLY that final slide in the "pages" array.
                
                                Step 3: Output Format (JSON)
                                Return ONLY a valid JSON array following this structure. Do not include any other text or markdown fences.
                                The page numbers should be 1-based (e.g., the first page is 1).
                
                                - **Language:** Your response (especially the "title" fields) **must** be in the primary language detected from the input (e.g., if the text is in German, the titles must be in German).

                                [
                                    {
                                        "title": "A descriptive title for this section",
                                        "pages": [/* array of page numbers (integers) in this group */]
                                    },
                                    {
                                        "title": "Title for the next section",
                                        "pages": [/* ... */]
                                    }
                                ]
                
                                Analyze the attached PDF file and return the JSON.
                                `;
                                filePayload = pdfDataB64;
                        } else {
                                prompt = `
                                Task:
                                Analyze the provided text content from a slide presentation and structure it for Anki card creation.
                                The text is formatted with "--- PAGE [number] ---" delimiters.
                
                                ${step1Instruction}

                                Step 2: Filter Only Truly Useless Slides
                                - Only REMOVE slides that are purely administrative or structural and contain NO actual new content.
                                - Examples of slides to remove:
                                    - Main title pages (e.g., "Presentation Title", "By [Author]")
                                    - Section divider slides (e.g., "Part 2: The Next Step")
                                    - "Agenda", "Outline", or "Overview" slides.
                                    - "Learning Objectives" slides.
                                    - "Thank you", "Questions?", or "Contact Information" slides.
                                    - Slides that are blank or have almost no content (e.g., just a title and no body, or a single image).
                                - DO NOT remove any slide that introduces new information, concepts, or explanations, even if it is labeled as a summary, recap, or conclusion, as long as it contains actual new content.
                                - For incremental slides (where one slide builds on the previous one), identify the *final* slide in that sequence and include ONLY that final slide in the "pages" array.
                
                                Step 3: Output Format (JSON)
                                Return ONLY a valid JSON array following this structure. Do not include any other text or markdown fences.

                                - **Language:** Your response (especially the "title" fields) **must** be in the primary language detected from the input (e.g., if the text is in German, the titles must be in German).
                
                                [
                                    {
                                        "title": "A descriptive title for this section",
                                        "pages": [/* array of page numbers (integers) in this group */]
                                    },
                                    {
                                        "title": "Title for the next section",
                                        "pages": [/* ... */]
                                    }
                                ]
                
                                Here is the slide text:
                                ${allPagesText}
                                `;
                                filePayload = null;
                        }
            
            let jsonString = await callGeminiWithRetry(prompt, config, model, filePayload);

            if (typeof jsonString === 'string') {
                const firstBrace = jsonString.indexOf('[');
                const firstCurly = jsonString.indexOf('{');
                
                let start = -1;
                
                if (firstBrace === -1 && firstCurly === -1) {
                    console.error("AI response did not contain JSON:", jsonString);
                    throw new Error("AI response did not contain a JSON array or object.");
                }

                if (firstBrace === -1) start = firstCurly;
                else if (firstCurly === -1) start = firstBrace;
                else start = Math.min(firstBrace, firstCurly);

                const lastBrace = jsonString.lastIndexOf(']');
                const lastCurly = jsonString.lastIndexOf('}');
                
                let end = Math.max(lastBrace, lastCurly);

                if (start === -1 || end === -1 || end < start) {
                     console.error("AI response had mismatched delimiters:", jsonString);
                     throw new Error("AI response had mismatched JSON delimiters.");
                }

                jsonString = jsonString.substring(start, end + 1);
            } else {
                return jsonString;
            }

            try {
                return JSON.parse(jsonString);
            } catch (e) {
                console.error("Failed to parse cleaned JSON string:", jsonString);
                throw new Error(`AI returned malformed JSON after cleaning: ${e.message}`);
            }
        }

        /**
         * Processes a single section (group of slides) and returns a Note object and stats.
         * This function is designed to be run in parallel.
         */
        async function processSection(pdfDoc, section, sectionIndex, model, baseTimestamp) {
            if (!section.pages || section.pages.length === 0) {
                // Return null or throw an error to be caught by allSettled
                throw new Error(`Section "${section.title}" has no pages.`);
            }

            // Get options from the DOM
            const slideBySlideMode = document.getElementById('slide-by-slide-checkbox').checked;
            const includeText = document.getElementById('include-text-checkbox').checked;
            
            let finalBackField = '';
            let finalBackContentField = '';
            
            const groupedText = await extractTextForPages(pdfDoc, section.pages);

            if (slideBySlideMode) {
                // --- Slide-by-Slide Mode ---
                const slidePromises = section.pages.map(async (pageNum) => {
                    const imageHtml = await renderImageForPage(pdfDoc, pageNum);
                    const pageText = await extractTextForPage(pdfDoc, pageNum);
                    let annotation = await callGeminiForSlideAnnotation(pageText);
                    
                    let html = imageHtml;
                    if (annotation.trim() && !annotation.includes("")) {
                        html += `<div class="slide-annotation">${annotation}</div>`;
                    }
                    return html;
                });
                
                const slideHtmls = await Promise.all(slidePromises);
                finalBackField = slideHtmls.join('');
                finalBackContentField = '';

            } else {
                // --- Default (Group) Mode ---
                const imagePromise = renderImagesForPages(pdfDoc, section.pages);
                const explanationPromise = callGeminiForExplanation(groupedText);

                const [imageResult, explanation] = await Promise.all([
                    imagePromise,
                    explanationPromise
                ]);

                finalBackField = imageResult.combinedImageHtml;
                finalBackContentField = explanation;
            }

            const orderField = `${baseTimestamp}${sectionIndex.toString().padStart(4, '0')}`;
            const textSearchField = includeText ? groupedText : '';

            const note = model.note([
                orderField,
                section.title,
                finalBackField,
                finalBackContentField,
                textSearchField
            ]);
            
            const stats = [section.title, section.pages.length, section.pages[0]];
            
            return { note, stats };
        }


        /**
         * Creates the .apkg file based on the AI's grouping.
         */
        async function createDeckFromConfig(pdfDoc, jsonConfig) {
            // --- Model and Deck Setup ---
            const m = new Model({
                name: "AI Slides - " + Date.now(),
                id: "1543634829845", 
                flds: [
                    { name: "Order" },      
                    { name: "Front" },      
                    { name: "Back" },       
                    { name: "BackContent" },
                    { name: "Text" },       
                ],
                req: [[0, "all", [0]]],
                tmpls: [{
                    name: "Card 1",
                    qfmt: "{{Front}}",
                    afmt: "{{FrontSide}}<hr id=answer>{{Back}}<br><div class=\"back-content\">{{BackContent}}</div>",
                }],
                css: `
                    .card { font-family: arial; font-size: 20px; text-align: center; color: black; }
                    .back-content { font-size: 16px; display: inline-block; text-align: left; width: 100%; max-width: 700px; line-height: 1.6; margin: 10px auto; padding: 10px; border-radius: 5px; border: 1px solid #eee; }
                    .slide-annotation {
                        font-size: 14px;
                        display: inline-block;
                        text-align: left;
                        width: 100%;
                        max-width: 700px;
                        line-height: 1.5;
                        margin: 5px auto 15px auto;
                        padding: 10px;
                        background-color: #f0f0f0;
                        border-radius: 5px;
                        border: 1px solid #ddd;
                    }
                    h2 { display: inline; }
                    img { max-width: 95%; height: auto; }
                `,
            });

            const deckName = pdfFile.name.replace(/\.[^/.]+$/, "");
            const d = new Deck(Date.now(), deckName);
            const baseTimestamp = new Date().getTime();

            // --- Concurrency Limit Logic ---
            const totalSections = jsonConfig.length;
            const maxParallelThreads = parseInt(maxParallelInput.value) || 10;
            updateProgress(`Processing ${totalSections} sections (in parallel batches of ${maxParallelThreads})...`, 30);
            
            const results = new Array(totalSections).fill(null);
            let completedCount = 0;

            const runTask = async (index) => {
                const section = jsonConfig[index];
                try {
                    const result = await processSection(pdfDoc, section, index, m, baseTimestamp);
                    results[index] = { status: 'fulfilled', value: result };
                } catch (error) {
                    results[index] = { status: 'rejected', reason: error };
                }
                
                completedCount++;
                const progressPercent = 30 + (completedCount / totalSections) * 65;
                updateProgress(`Processing section ${completedCount} of ${totalSections}...`, progressPercent);
            };

            const pool = new Set();
            
            for (let i = 0; i < totalSections; i++) {
                const promise = runTask(i);
                pool.add(promise);
                
                promise.then(() => pool.delete(promise));

                if (pool.size >= maxParallelThreads) {
                    await Promise.race(pool);
                }
            }
            
            await Promise.allSettled(Array.from(pool));
            // --- End Concurrency Logic ---

            // --- Process results ---
            const allNotes = [];
            const cardStats = [];
            let failedSections = 0;

            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    const { note, stats } = result.value;
                    allNotes.push(note);
                    cardStats.push(stats);
                } else {
                    const sectionTitle = jsonConfig[index] ? jsonConfig[index].title : `Section ${index + 1}`;
                    console.error(`Failed to process section "${sectionTitle}":`, result.reason);
                    failedSections++;
                }
            });

            allNotes.sort((a, b) => a.fields[0].localeCompare(b.fields[0]));
            allNotes.forEach(note => d.addNote(note));
            
            if (failedSections > 0) {
                const successfulCards = allNotes.length;
                showError(`Warning: ${failedSections} card(s) failed to generate. ${successfulCards} card(s) were created successfully. Check console for details.`);
            }

            updateProgress("Creating .apkg file...", 95);
            const p = new Package();
            p.addDeck(d);
            const apkgArrayBuffer = await p.writeToFile(`${deckName}.apkg`);

            const blob = new Blob([apkgArrayBuffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `${deckName}.apkg`;
            downloadLink.textContent = `Download ${deckName}.apkg`;
            downloadArea.appendChild(downloadLink);

            updateStats(deckName, allNotes.length, cardStats, pdfDoc.numPages);
        }


        /**
         * Renders a single page to an <img> tag string.
         * --- MODIFIED with auto-cropping padding ---
         */
        async function renderImageForPage(pdfDoc, pageNum) {
            // Get options
            const compressImages = compressImagesCheckbox.checked;
            const autoCrop = autoCropCheckbox.checked;
            const maxResolution = parseInt(maxResolutionInput.value);
            const maxSizeKB = parseInt(maxSizeInput.value);

            const page = await pdfDoc.getPage(pageNum);
            const scale = 2; // Render at 2x for clarity
            const viewport = page.getViewport({ scale });

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { willReadFrequently: true });
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ 
                canvasContext: context, 
                viewport,
                willReadFrequently: true 
            }).promise;

            // --- AUTO-CROP LOGIC ---
            let finalCanvas = canvas; // Default to the original canvas

            if (autoCrop) {
                try {
                    const { data, width, height } = context.getImageData(0, 0, canvas.width, canvas.height);
                    const trimThreshold = 250; // Pixels lighter than this (per channel) are "white"
                    const padding = 15; // <-- *** PADDING ADDED ***

                    // Helper to check if a pixel has content
                    const isContent = (index) => {
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3];
                        return a > 0 && (r < trimThreshold || g < trimThreshold || b < trimThreshold);
                    };

                    let cropTop = 0, cropBottom = height, cropLeft = 0, cropRight = width;
                    let foundTop = false, foundBottom = false, foundLeft = false, foundRight = false;

                    // Find Top
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            if (isContent((y * width + x) * 4)) {
                                cropTop = y;
                                foundTop = true;
                                break;
                            }
                        }
                        if (foundTop) break;
                    }

                    // Find Bottom
                    if (foundTop) { // Only search if the slide isn't blank
                        for (let y = height - 1; y >= cropTop; y--) {
                            for (let x = 0; x < width; x++) {
                                if (isContent((y * width + x) * 4)) {
                                    cropBottom = y + 1; // +1 to make it exclusive
                                    foundBottom = true;
                                    break;
                                }
                            }
                            if (foundBottom) break;
                        }

                        // Find Left
                        for (let x = 0; x < width; x++) {
                            for (let y = cropTop; y < cropBottom; y++) {
                                if (isContent((y * width + x) * 4)) {
                                    cropLeft = x;
                                    foundLeft = true;
                                    break;
                                }
                            }
                            if (foundLeft) break;
                        }

                        // Find Right
                        for (let x = width - 1; x >= cropLeft; x--) {
                            for (let y = cropTop; y < cropBottom; y++) {
                                if (isContent((y * width + x) * 4)) {
                                    cropRight = x + 1; // +1 to make it exclusive
                                    foundRight = true;
                                    break;
                                }
                            }
                            if (foundRight) break;
                        }

                        // *** APPLY PADDING to the crop box ***
                        cropTop = Math.max(0, cropTop - padding);
                        cropBottom = Math.min(height, cropBottom + padding);
                        cropLeft = Math.max(0, cropLeft - padding);
                        cropRight = Math.min(width, cropRight + padding);

                        // Apply the crop if valid
                        const newWidth = cropRight - cropLeft;
                        const newHeight = cropBottom - cropTop;

                        if (newWidth > 0 && newHeight > 0) {
                            const cropCanvas = document.createElement('canvas');
                            const cropCtx = cropCanvas.getContext('2d');
                            cropCanvas.width = newWidth;
                            cropCanvas.height = newHeight;
                            
                            cropCtx.drawImage(
                                canvas,
                                cropLeft, cropTop, newWidth, newHeight, // Source (x, y, w, h)
                                0, 0, newWidth, newHeight             // Destination (x, y, w, h)
                            );
                            finalCanvas = cropCanvas; // Use the new cropped canvas
                        }
                    }
                } catch (e) {
                    console.error(`Auto-cropping failed for page ${pageNum}: ${e.message}. Using original image.`);
                    // Fallback: finalCanvas is already set to the original canvas
                }
            }
            // --- END AUTO-CROP LOGIC ---

            // Use the finalCanvas (either original or cropped) to generate the image
            let imageData = finalCanvas.toDataURL('image/jpeg', 0.9);

            // *** COMPRESSION LOGIC ***
            // This runs *after* cropping, using the imageData from finalCanvas
            if (compressImages) {
                const response = await fetch(imageData);
                const blob = await response.blob();
                const options = {
                    maxSizeMB: maxSizeKB / 1024,
                    maxWidthOrHeight: maxResolution,
                    useWebWorker: true,
                };
                try {
                    const compressedImage = await imageCompression(blob, options);
                    const reader = new FileReader();
                    reader.readAsDataURL(compressedImage);
                    await new Promise(resolve => reader.onload = resolve);
                    imageData = reader.result;
                } catch (error) {
                    console.error(`Image compression failed for page ${pageNum}:`, error);
                }
            }

            return `<img src="${imageData}">`;
        }

        /**
         * Renders the specified pages into a combined string of <img> tags.
         */
        async function renderImagesForPages(pdfDoc, pagesArray) {
            let combinedImageHtml = '';
            for (const [index, pageNum] of pagesArray.entries()) {
                const imageHtml = await renderImageForPage(pdfDoc, pageNum);
                combinedImageHtml += imageHtml;
                if (index < pagesArray.length - 1) {
                    combinedImageHtml += '<br>'; 
                }
            }
            return { combinedImageHtml, pageNum: pagesArray[0] };
        }

        /**
         * Extracts text from a single page.
         */
        async function extractTextForPage(pdfDoc, pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const textContent = await page.getTextContent();
            return `\n--- Slide (Page ${pageNum}) ---\n` + textContent.items.map(item => item.str).join(' ');
        }


        /**
         * Extracts text from a specific list of pages.
         */
        async function extractTextForPages(pdfDoc, pagesArray) {
            let groupedText = '';
            for (const pageNum of pagesArray) {
                groupedText += await extractTextForPage(pdfDoc, pageNum);
            }
            return groupedText.trim();
        }

        /**
        * Second Gemini call: To explain the content of a *group* of slides.
        */
        async function callGeminiForExplanation(groupedText) {
            const prompt = `
                Task:
                You will be given the text from a set of presentation slides on a specific topic.
                Your task is to provide a clear, comprehensive, and well-structured explanation of the content, as if you were teaching it to a student.
                
                Instructions:
                - **Language:** Respond in the **same language** as the provided slide text.
                - Do not just repeat the slide's bullet points.
                - Elaborate on the concepts, connect the ideas, and provide context.
                - Structure your explanation using simple HTML tags like <p>, <ul>, <li>, and <i>.
                - **For emphasis/bolding, use <b>...</b> tags. DO NOT use markdown asterisks (\`**...**\`).**
                - **Crucially for formulas (Anki/MathJax format):**
                    - For **inline math**, use the format: \\(...\\) (e.g., \\( E = mc^2 \\)).
                    - For **display/block math**, use the format: \\[...\\] (e.g., \\[ \\sum_{i=1}^{n} i = \\frac{n(n+1)}{2} \\]).
                    - **DO NOT** use single dollar signs ($...$) for math.
                - Respond ONLY with the HTML-formatted explanation. Do not add any preamble like "Here is the explanation:", "Sure!", or markdown fences.
                
                Here is the slide text:
                ${groupedText}
            `;

            try {
                return await callGeminiWithRetry(prompt); 
            } catch (error) {
                console.error("Error in explanation call:", error);
                return `<p>(AI explanation failed: ${error.message})</p>`;
            }
        }

        /**
        * Third Gemini call: To annotate a *single* slide, only if needed.
        */
        async function callGeminiForSlideAnnotation(singlePageText) {
            const prompt = `
                Task:
                You will be given the text from a single presentation slide.
                Your task is to provide a brief, clarifying explanation (an "annotation") for this slide *only if it is not self-explanatory*.

                Instructions:
                1.  **Analyze the text:**
                    - If the slide text is just a title, a formula, a diagram description, or a list of keywords, it **needs** an explanation.
                    - If the slide text is already a set of complete sentences or self-explanatory bullet points, it **does not** need an explanation.
                2.  **Response Format (Crucial!):**
                    - If an explanation is needed: Respond ONLY with the explanation, formatted in simple HTML.
                      - Use tags like <p>, <ul>, <li>.
                      - **For bolding, use <b>...</b> tags, NOT markdown asterisks (\`**...**\`).**
                      - Use MathJax format (\\(...\\) and \\[...\\]) for any math. Keep it brief.
                    - If no explanation is needed: Respond ONLY with the exact string "".
                3.  **DO NOT** add any other preamble, markdown, or text.
                4.  **Language:** Respond in the **same language** as the provided slide text.

                Here is the slide text:
                ${singlePageText}
            `;

            try {
                return await callGeminiWithRetry(prompt);
            } catch (error) {
                console.error("Error in annotation call:", error);
                return `<p>(AI annotation failed: ${error.message})</p>`;
            }
        }


        // --- Utility Functions ---
        function updateStats(deckName, totalCards, cardStats, totalPages) {
            let statsHTML = `<h3>Stats for ${deckName}</h3>`;
            statsHTML += `<p>Total PDF pages: ${totalPages}</p>`;
            statsHTML += `<p>Total Anki cards created: ${totalCards}</p>`;
            statsHTML += `<h4>Card details (based on AI grouping):</h4>`;
            statsHTML += `<ul>`;
            for (const [title, imageCount, pageNum] of cardStats) {
                statsHTML += `<li>"${title}": ${imageCount} slide${imageCount !== 1 ? 's' : ''} (starting from page ${pageNum})</li>`;
            }
            statsHTML += `</ul>`;
            statsArea.innerHTML = statsHTML;
        }

        var coll = document.getElementsByClassName("collapsible");
        for (let i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                } else {
                    content.style.display = "block";
                }
            });
        }
    </script>
</body>

</html>