<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered PDF to Anki Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/krmanik/genanki-js/dist/genanki.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression/dist/browser-image-compression.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }

        h1 {
            text-align: center;
        }

        #app-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .config-section,
        .upload-section,
        .options-section,
        .action-section {
            margin-bottom: 20px;
        }

        label {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        
        /* Make checkbox labels more clickable */
        input[type="checkbox"] + label,
        input[type="radio"] + label {
            display: inline-block;
            font-weight: normal;
            cursor: pointer;
        }

        input[type="password"],
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }
        
        select {
            background-color: white;
        }

        .button,
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 18px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        .button:hover,
        button:hover {
            background-color: #0056b3;
        }
        
        #clear-key-button:hover {
             background-color: #c82333;
        }

        button:disabled {
            background-color: #c0c0c0;
            cursor: not-allowed;
        }

        #drop-area {
            border: 2px dashed #ddd;
            border-radius: 4px;
            padding: 30px;
            text-align: center;
            background-color: #fafafa;
        }

        #drop-area.highlight {
            border-color: #007bff;
            background-color: #f0f8ff;
        }

        #file-input {
            display: none;
        }

        .file-item {
            background-color: #f4f4f4;
            padding: 10px;
            margin-top: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #progress-area {
            margin-top: 20px;
        }
        
        #progress-area p {
            margin-bottom: 8px;
        }

        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar-fill {
            width: 0%;
            height: 20px;
            background-color: #4caf50;
            transition: width 0.3s;
        }

        .error-message {
            color: #dc3545;
            margin: 10px 0;
            padding: 10px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
        }

        .info-box {
            background-color: #e6f7ff;
            border: 1px solid #b3e0ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        #download-area a {
            display: block;
            background-color: #28a745;
            color: white;
            text-align: center;
            padding: 12px;
            border-radius: 4px;
            text-decoration: none;
            font-weight: bold;
            margin-top: 10px;
        }

        #download-area a:hover {
            background-color: #218838;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        /* Your existing styles */
        .removed-slides-list {
            list-style-type: none;
            padding-left: 0;
        }

        .removed-slides-list li {
            background-color: #ffebee;
            border-left: 3px solid #f44336;
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 3px;
        }

        #removed-slides-container {
            margin-top: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        #removed-slides-summary {
            font-weight: bold;
            font-size: 1.1em;
            background-color: #fff8e1;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #ffe082;
        }

        .collapsible {
            background-color: #eee;
            color: #444;
            cursor: pointer;
            padding: 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 15px;
            margin-top: 10px;
        }

        .active,
        .collapsible:hover {
            background-color: #ccc;
        }

        .content {
            padding: 0 18px;
            display: none;
            overflow: hidden;
            background-color: #f1f1f1;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <h1>AI-Powered PDF to Anki Converter</h1>

        <div class="info-box">
            <p><b>How it works:</b>
            <ol>
                <li>Enter one or more Google AI (Gemini) API Keys (one per line). (You can save these to your browser).</li>
                <li>Upload a single PDF file.</li>
                <li>The app sends your PDF (or its text, per your settings) to Gemini to get a JSON list of grouped slides.</li>
                <li><b>Choose a mode:</b>
                    <ul>
                        <li><b>Default Mode:</b> For each *group*, it sends the text to Gemini again to get a detailed explanation for the "BackContent" field.</li>
                        <li><b>Annotation Mode:</b> For *each slide* in a group, it asks Gemini for a brief annotation *if needed*. This is added below the slide image in the "Back" field.</li>
                    </ul>
                </li>
                <li>It then builds an Anki deck with the slide images and AI explanations.</li>
            </ol>
            </p>
            <p>⚠️ <b>Warning:</b> This tool makes many API calls and may be slow. **Slide-by-slide mode makes significantly MORE calls.**</p>
            <p>✅ <b>New:</b> The tool automatically retries on rate limits or 503 (model overloaded) errors. If all your keys are busy, it will show a **countdown timer** and wait for the soonest one to be available.</p>
        </div>

        <div class="config-section">
            <label for="api-keys-textarea">Gemini API Keys (one per line):</label>
            <textarea id="api-keys-textarea" rows="4" placeholder="Enter one or more Google AI API Keys here, each on a new line..."></textarea>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                 <button id="save-key-button" style="padding: 10px 15px;">Save Keys</button>
                 <button id="clear-key-button" style="padding: 10px 15px; background-color: #dc3545;">Clear Keys</button>
            </div>
            <a href="https://aistudio.google.com/app/apikey" target="_blank" style="display: block; margin-top: 5px;">Get your API key here</a>
        </div>

        <div class="upload-section">
            <div id="drop-area">
                <form class="my-form">
                    <p>Upload a single PDF file by dragging and dropping or clicking below</p>
                    <input type="file" id="file-input" accept="application/pdf">
                    <label for="file-input" class="button">Upload Full PDF</label>
                </form>
            </div>
            <div id="file-list"></div>
        </div>

        <div class="options-section">
            <h3>Options</h3>
            <div class="options-grid">
                <div>
                    <input type="checkbox" id="compress-images-checkbox" checked>
                    <label for="compress-images-checkbox">Compress images</label>
                </div>
                <div>
                    <input type="checkbox" id="include-text-checkbox" checked>
                    <label for="include-text-checkbox">Include original slide text (for search)</label>
                </div>
                <div>
                    <label for="max-resolution-input">Max image width (px):</label>
                    <input type="number" id="max-resolution-input" value="1800" min="1" style="width: 100px;">
                </div>
                <div>
                    <label for="max-size-input">Max image size (kB):</label>
                    <input type="number" id="max-size-input" value="400" min="1" style="width: 100px;">
                </div>

                <div style="grid-column: 1 / -1; border-top: 1px solid #eee; padding-top: 15px;">
                    <label for="grouping-model-select"><b>Grouping AI Model:</b></label>
                    <select id="grouping-model-select">
                        <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash Lite (Fast)</option>
                        <option value="gemini-2.5-flash" selected>Gemini 2.5 Flash (Advanced, Stable, Default)</option>
                        <option value="gemini-2.5-pro">Gemini 2.5 Pro (Newest, Slower)</option>
                    </select>
                </div>
                <div style="grid-column: 1 / -1;">
                    <label><b>Grouping Input Method:</b></label>
                    <div style="background-color: #f9f9f9; padding: 10px; border-radius: 4px; border: 1px solid #eee;">
                        <input type="radio" id="input-text" name="grouping-input" value="text" checked>
                        <label for="input-text">Send Extracted Text (Default, Fast)</label>
                        <br>
                        <input type="radio" id="input-file" name="grouping-input" value="file">
                        <label for="input-file">Upload Full PDF (Slower, may be more accurate)</label>
                    </div>
                </div>
                
                <div style="grid-column: 1 / -1; border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
                    <label for="max-parallel-input">Max parallel tasks:</label>
                    <input type="number" id="max-parallel-input" value="10" min="1" style="width: 100px;">
                    <label for="max-parallel-input" style="font-weight: normal; display: inline;">(Limits concurrent AI calls/image renders to save memory)</label>
                </div>
                <div style="grid-column: 1 / -1; border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
                    <input type="checkbox" id="detailed-grouping-checkbox">
                    <label for="detailed-grouping-checkbox"><b>Enable detailed (smaller) slide grouping</b><br>(Creates more cards with fewer slides each. Good for long or dense PDFs.)</label>
                </div>
                <div style="grid-column: 1 / -1; background-color: #fff8e1; padding: 10px; border-radius: 4px; border: 1px solid #ffe082; margin-top: 10px;">
                    <input type="checkbox" id="slide-by-slide-checkbox">
                    <label for="slide-by-slide-checkbox"><b>Slide-by-slide annotation mode</b><br>(Adds explanations *below each slide* if needed, instead of one big explanation. Makes many more API calls.)</label>
                </div>
            </div>
        </div>

        <div class="action-section">
            <button id="generate-button" disabled>Generate Anki Deck</button>
        </div>

        <div id="progress-area"></div>
        <div id="json-error" class="error-message" style="display: none;"></div>
        <div id="download-area"></div>

        <button type="button" class="collapsible">Stats</button>
        <div class="content">
            <div id="stats-area"></div>
        </div>
    </div>

    <script>
        // --- Setup Libraries ---
        config = {
            locateFile: filename => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${filename}`
        }
        var SQL;
        initSqlJs(config).then(function (sql) {
            SQL = sql;
        });
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        // --- Get DOM Elements ---
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const generateButton = document.getElementById('generate-button');
        const fileList = document.getElementById('file-list');
        const progressArea = document.getElementById('progress-area');
        const statsArea = document.getElementById('stats-area');
        const downloadArea = document.getElementById('download-area');
        const apiKeysTextarea = document.getElementById('api-keys-textarea'); // Changed
        const saveKeyButton = document.getElementById('save-key-button');
        const clearKeyButton = document.getElementById('clear-key-button');
        const jsonError = document.getElementById('json-error');

        // --- Options ---
        const includeTextCheckbox = document.getElementById('include-text-checkbox');
        const compressImagesCheckbox = document.getElementById('compress-images-checkbox');
        const maxResolutionInput = document.getElementById('max-resolution-input');
        const maxSizeInput = document.getElementById('max-size-input');
        const slideBySlideCheckbox = document.getElementById('slide-by-slide-checkbox');
        const detailedGroupingCheckbox = document.getElementById('detailed-grouping-checkbox');
        const groupingModelSelect = document.getElementById('grouping-model-select');
        const groupingInputText = document.getElementById('input-text');
        const groupingInputFile = document.getElementById('input-file');
        const maxParallelInput = document.getElementById('max-parallel-input'); // <-- ADDED

        // --- State ---
        let pdfFile = null;
        let keyPool = []; // New: To manage multiple API keys

        // --- Event Listeners ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        dropArea.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);
        generateButton.addEventListener('click', generateAnkiDecks, false);
        apiKeysTextarea.addEventListener('input', checkReady); // Changed
        saveKeyButton.addEventListener('click', saveApiKeys); // Changed
        clearKeyButton.addEventListener('click', clearApiKeys); // Changed

        // Add listeners for all options
        [
            compressImagesCheckbox, includeTextCheckbox, slideBySlideCheckbox, 
            maxResolutionInput, maxSizeInput, groupingModelSelect, 
            groupingInputText, groupingInputFile, detailedGroupingCheckbox,
            maxParallelInput // <-- ADDED
        ].forEach(el => { 
            el.addEventListener('change', saveOptions);
        });

        // --- Initial Load ---
        loadApiKeys(); // Changed
        loadOptions(); // New

        // --- Drag and Drop Handlers ---
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        function highlight() { dropArea.classList.add('highlight'); }
        function unhighlight() { dropArea.classList.remove('highlight'); }
        function handleDrop(e) { handleFiles(e.dataTransfer.files); }

        function handleFiles(filesOrEvent) {
            let files;
            if (filesOrEvent instanceof Event) {
                files = filesOrEvent.target.files;
            } else {
                files = filesOrEvent;
            }

            if (files && files.length > 0) {
                pdfFile = files[0];
                updateFileList();
                checkReady();
            }
        }
        function updateFileList() {
            fileList.innerHTML = '<h3>Selected File:</h3>';
            if (pdfFile) {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `
                    <span>${pdfFile.name}</span>
                    <span class"remove-file" style="cursor: pointer; color: red;" onclick="clearFile()">&#10005;</span>
                `;
                fileList.appendChild(div);
            }
        }

        function clearFile() {
            pdfFile = null;
            fileList.innerHTML = '';
            fileInput.value = '';
            checkReady();
        }

        function checkReady() {
            generateButton.disabled = !(pdfFile && apiKeysTextarea.value.trim() !== ''); // Changed
        }

        // --- API Key Storage Functions ---
        function saveApiKeys() { // Changed
            const apiKeys = apiKeysTextarea.value; // Don't trim, preserve newlines
            if (apiKeys) {
                localStorage.setItem('geminiAnkiApiKeys', apiKeys); // Changed key
                alert('API Keys saved to browser storage.');
            } else {
                alert('Please enter at least one API key to save.');
            }
        }

        function clearApiKeys() { // Changed
            localStorage.removeItem('geminiAnkiApiKeys'); // Changed key
            apiKeysTextarea.value = '';
            checkReady();
            alert('API Keys cleared from browser storage.');
        }

        function loadApiKeys() { // Changed
            const savedKeys = localStorage.getItem('geminiAnkiApiKeys'); // Changed key
            if (savedKeys) {
                apiKeysTextarea.value = savedKeys;
                checkReady();
            }
        }

        // --- New Options Storage Functions ---
        function saveOptions() {
            localStorage.setItem('geminiAnkiOptions', JSON.stringify({
                compressImages: compressImagesCheckbox.checked,
                includeText: includeTextCheckbox.checked,
                maxResolution: maxResolutionInput.value,
                maxSize: maxSizeInput.value,
                slideBySlide: slideBySlideCheckbox.checked,
                detailedGrouping: detailedGroupingCheckbox.checked,
                groupingModel: groupingModelSelect.value,
                groupingInput: groupingInputText.checked ? 'text' : 'file',
                maxParallel: maxParallelInput.value // <-- ADDED
            }));
        }

        function loadOptions() {
            const savedOptions = localStorage.getItem('geminiAnkiOptions');
            if (savedOptions) {
                try {
                    const options = JSON.parse(savedOptions);
                    // Set values, providing defaults for undefined properties
                    compressImagesCheckbox.checked = options.compressImages !== false; // default true
                    includeTextCheckbox.checked = options.includeText !== false; // default true
                    slideBySlideCheckbox.checked = options.slideBySlide === true; // default false
                    detailedGroupingCheckbox.checked = options.detailedGrouping === true; // default false
                    if (options.maxResolution) maxResolutionInput.value = options.maxResolution;
                    if (options.maxSize) maxSizeInput.value = options.maxSize;
                    if (options.groupingModel) groupingModelSelect.value = options.groupingModel;
                    if (options.maxParallel) maxParallelInput.value = options.maxParallel; // <-- ADDED
                    
                    if (options.groupingInput === 'file') {
                        groupingInputFile.checked = true;
                    } else {
                        groupingInputText.checked = true;
                    }
                } catch (e) {
                    console.error("Failed to load saved options:", e);
                    localStorage.removeItem('geminiAnkiOptions'); // Clear corrupted data
                }
            }
        }
        
        // --- Progress and Error Updates ---
        function updateProgress(message, percentage) {
            let percentValue = percentage;
            if (typeof percentValue === 'undefined') {
                 const progressBarFill = document.querySelector('.progress-bar-fill');
                 percentValue = progressBarFill ? progressBarFill.style.width : '0%';
            }
            
            progressArea.innerHTML = `
                <p>${message}</p>
                <div class="progress-bar">
                    <span class="progress-bar-fill" style="width: ${percentValue};"></span>
                </div>
            `;
        }

        function showError(message) {
            jsonError.textContent = message;
            jsonError.style.display = 'block';
            updateProgress("Error encountered.", 0);
            generateButton.disabled = false;
        }

        // --- Main Anki Generation Logic ---
        async function generateAnkiDecks() {
            generateButton.disabled = true;
            jsonError.style.display = 'none';
            statsArea.innerHTML = '';
            downloadArea.innerHTML = '';
            updateProgress("Starting...", 0);

            if (!pdfFile || !apiKeysTextarea.value.trim()) { // Changed
                showError("Please provide both a PDF file and at least one Gemini API Key.");
                return;
            }

            // New: Initialize the key pool
            const apiKeysString = apiKeysTextarea.value.trim();
            keyPool = apiKeysString.split('\n')
                .filter(k => k.trim() !== '')
                .map(key => ({ key: key.trim(), availableAt: 0 }));

            if (keyPool.length === 0) {
                showError("Please provide at least one valid API Key.");
                return;
            }

            let pdfDoc;

            // Get options
            const groupingModel = groupingModelSelect.value;
            const groupingInput = groupingInputText.checked ? 'text' : 'file';

            try {
                updateProgress("Loading PDF...", 5);
                pdfDoc = await pdfjsLib.getDocument(URL.createObjectURL(pdfFile)).promise;

                let allPagesText = null;
                let pdfDataB64 = null;

                if (groupingInput === 'file') {
                    updateProgress("Reading PDF for upload...", 15);
                    pdfDataB64 = await fileToBase64(pdfFile);
                } else {
                    updateProgress("Extracting text from all pages...", 10);
                    allPagesText = await extractAllText(pdfDoc);
                }

                updateProgress("Asking AI to group and filter slides...", 20);
                const groupingJSON = await callGeminiForGrouping(allPagesText, groupingModel, groupingInput, pdfDataB64);

                if (!groupingJSON || !Array.isArray(groupingJSON)) {
                    showError("AI did not return valid JSON for grouping. Check console for details.");
                    console.error("Invalid JSON response:", groupingJSON);
                    return;
                }

                updateProgress("AI grouping received. Starting deck generation...", 30);
                await createDeckFromConfig(pdfDoc, groupingJSON); // pdfDoc passed here

                updateProgress("Anki deck generated!", 100);

            } catch (error) {
                showError(`An error occurred: ${error.message}`);
                console.error(error);
            } finally {
                generateButton.disabled = false;
            }
        }

        /**
         * Extracts text from every page of the PDF.
         */
        async function extractAllText(pdfDoc) {
            let allText = '';
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                allText += `\n\n--- PAGE ${pageNum} ---\n${pageText}\n`;
            }
            return allText;
        }

        // --- Helper function for sleeping ---
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- New Countdown Timer ---
        async function showWaitingCountdown(totalWaitMs, baseMessage, percentage) {
            updateProgress(`${baseMessage} Waiting for ${Math.ceil(totalWaitMs / 1000)}s...`, percentage);
            await sleep(totalWaitMs);
        }

        // --- New Base64 Helper ---
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // Get data part (after 'base64,')
                    const base64Data = reader.result.split(',')[1];
                    resolve(base64Data);
                };
                reader.onerror = error => reject(error);
            });
        }

        // --- Universal API caller with retry logic ---
        /**
         * Makes a call to the Gemini API with automatic retry and key rotation.
         * Relies on the global `keyPool` variable.
         * Can optionally send Base64-encoded file data.
         */
        async function callGeminiWithRetry(prompt, generationConfig = null, model = 'gemini-2.5-flash-lite', fileBytesBase64 = null) {
            if (!keyPool || keyPool.length === 0) {
                throw new Error("API Key pool is empty.");
            }

            let retryCount = 0;

            while (true) {
                const now = Date.now();
                
                // 1. Find an available key
                let keyEntry = null;
                for (const entry of keyPool) {
                    if (now >= entry.availableAt) {
                        keyEntry = entry;
                        break; // Found a usable key
                    }
                }
                
                // Store current progress *before* any potential waiting
                const progressBarFill = document.querySelector('.progress-bar-fill');
                const currentPercentage = progressBarFill ? progressBarFill.style.width : '0%';
                const currentProgressMessage = progressArea.querySelector('p') ? progressArea.querySelector('p').textContent : 'Processing...';

                // 2. If no key is available, wait for the soonest one (WITH COUNTDOWN)
                if (!keyEntry) {
                    const soonestAvailableTime = Math.min(...keyPool.map(k => k.availableAt));
                    const waitMs = (soonestAvailableTime - now) + 1000; // 1s buffer
                    
                    console.warn(`All keys busy/rate-limited. Waiting for ${waitMs / 1000}s...`);
                    
                    // Start the countdown
                    await showWaitingCountdown(waitMs, `All keys busy. Pausing... (Retry #${retryCount})`, currentPercentage);
                    
                    // After countdown, restore original message and continue loop
                    updateProgress(currentProgressMessage, currentPercentage);
                    continue; // Restart the loop to find a key
                }

                // 3. We have a key. Try to use it.
                const apiKey = keyEntry.key;
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

                // Build the request parts
                const parts = [{ text: prompt }];
                if (fileBytesBase64) {
                    parts.push({
                        inlineData: {
                            mimeType: 'application/pdf',
                            data: fileBytesBase64
                        }
                    });
                }
                
                const body = {
                    contents: [{ parts: parts }]
                };

                if (generationConfig) {
                    body.generationConfig = generationConfig;
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts[0]) {
                            return data.candidates[0].content.parts[0].text; // SUCCESS!
                        } else {
                            throw new Error("Invalid successful response structure from Gemini.");
                        }
                    }

                    const errorBody = await response.json();
                    const errorMessage = errorBody.error ? errorBody.error.message : "Unknown API error";

                    // 4. Handle 503 / Overloaded
                    if (response.status === 503 || errorMessage.includes("model is overloaded")) {
                        const waitMs = 15000; // Wait 15s for this key
                        keyEntry.availableAt = Date.now() + waitMs;
                        
                        console.warn(`Model is overloaded for key ...${apiKey.slice(-4)}. Retrying after ${waitMs / 1000}s.`);
                        updateProgress(`Model overloaded (Key: ...${apiKey.slice(-4)}). Trying next key... (Retry #${retryCount})`, currentPercentage);
                        await sleep(500); // Brief pause to show message
                        updateProgress(currentProgressMessage, currentPercentage); // Restore message
                        
                        retryCount++;
                        continue; // Loop again to find a *different* key
                    }

                    // 5. Handle Rate Limit
                    if (errorMessage.includes("Quota exceeded") && errorMessage.includes("Please retry in")) {
                        const match = errorMessage.match(/Please retry in ([\d\.]+)s/);
                        
                        if (match && match[1]) {
                            const waitTimeS = parseFloat(match[1]);
                            
                            if (waitTimeS > 300) { // 5-minute hard limit
                                throw new Error(`Rate limit retry time (${waitTimeS.toFixed(1)}s) for key ending in ...${apiKey.slice(-4)} exceeds 5 minutes. Aborting. Full error: ${errorMessage}`);
                            }

                            const waitMs = (waitTimeS * 1000) + 1000; // 1s buffer
                            // Update this specific key's availability
                            keyEntry.availableAt = Date.now() + waitMs; 
                            
                            console.warn(`Gemini rate limit hit for key ...${apiKey.slice(-4)}. Setting cool-down for ${waitTimeS.toFixed(1)}s. Trying next key...`);
                            
                            updateProgress(`Key ...${apiKey.slice(-4)} rate-limited. Trying next key... (Retry #${retryCount})`, currentPercentage);
                            await sleep(500); // Brief pause to show message
                            updateProgress(currentProgressMessage, currentPercentage); // Restore message
                            
                            retryCount++;
                            continue; // Loop again to find a *different* key
                        }
                    }
                    
                    // 6. Handle Other API Errors (like invalid key)
                    if (response.status === 400 || response.status === 403) {
                         keyEntry.availableAt = Date.now() + 86400000; // Disable for 24h
                         console.error(`API Key ...${apiKey.slice(-4)} is invalid or unauthorized. Disabling it for 24h. Error: ${errorMessage}`);
                         updateProgress(`Key ...${apiKey.slice(-4)} is invalid. Trying next... (Retry #${retryCount})`, currentPercentage);
                         await sleep(500);
                         updateProgress(currentProgressMessage, currentPercentage);
                         retryCount++;
                         continue; // Try next key
                    }

                    throw new Error(`Gemini API error (Key: ...${apiKey.slice(-4)}): ${errorMessage}`);

                } catch (error) {
                    console.error(`Network or fetch error (Key: ...${apiKey.slice(-4)}):`, error);
                    // Penalize key for network errors too?
                    keyEntry.availableAt = Date.now() + 30000; // Wait 30s before retrying this key
                    console.warn(`Pausing key ...${apiKey.slice(-4)} for 30s due to network error.`);
                    retryCount++;
                    continue; // Try next key
                }
            }
        }


        /**
         * First Gemini call: To group slides and remove unwanted ones.
         */
        async function callGeminiForGrouping(allPagesText, model, inputType, pdfDataB64) {
            let prompt;
            let filePayload = null;
            const config = { responseMimeType: "application/json" };
            const useDetailedGrouping = detailedGroupingCheckbox.checked; // <-- ADDED

            // --- THIS BLOCK IS NEW/MODIFIED ---
            const step1Instruction = useDetailedGrouping
                ? `Step 1: Identify Logical Sections
                - Your goal is to create **small, focused groups**.
                - A group should ideally cover only **one or two key concepts** and be **1-4 slides long**.
                - **Do NOT create large groups** (e.g., 10+ slides).
                - It is better to have many small, specific groups than a few large, general ones.`
                : `Step 1: Identify Logical Sections
                Group pages together that cover a single, distinct topic.`;
            // --- END MODIFIED BLOCK ---

            if (inputType === 'file') {
                prompt = `
                Task:
                Analyze the provided PDF presentation and structure it for Anki card creation.
                
                ${step1Instruction}

                Step 2: Filter Unwanted Slides
                - Your filtering must be strict. REMOVE any slides that are purely administrative or structural.
                - This includes, but is not limited to:
                  - Main title pages (e.g., "Presentation Title", "By [Author]")
                  - Section divider slides (e.g., "Part 2: The Next Step")
                  - "Agenda", "Outline", or "Overview" slides.
                  - "Learning Objectives" slides.
                  - "Thank you", "Questions?", or "Contact Information" slides.
                  - Any slide with almost no content (e.g., just a title and no body, or a single image).
                - For incremental slides (where one slide builds on the previous one), identify the *final* slide in that sequence and include ONLY that final slide in the "pages" array.
                
                Step 3: Output Format (JSON)
                Return ONLY a valid JSON array following this structure. Do not include any other text or markdown fences.
                The page numbers should be 1-based (e.g., the first page is 1).
                
                - **Language:** Your response (especially the "title" fields) **must** be in the primary language detected from the input (e.g., if the text is in German, the titles must be in German).

                [
                  {
                    "title": "A descriptive title for this section",
                    "pages": [/* array of page numbers (integers) in this group */]
                  },
                  {
                    "title": "Title for the next section",
                    "pages": [/* ... */]
                  }
                ]
                
                Analyze the attached PDF file and return the JSON.
                `;
                filePayload = pdfDataB64;
            } else {
                prompt = `
                Task:
                Analyze the provided text content from a slide presentation and structure it for Anki card creation.
                The text is formatted with "--- PAGE [number] ---" delimiters.
                
                ${step1Instruction}

                Step 2: Filter Unwanted Slides
                - Your filtering must be strict. REMOVE any slides that are purely administrative or structural.
                - This includes, but is not limited to:
                  - Main title pages (e.g., "Presentation Title", "By [Author]")
                  - Section divider slides (e.g., "Part 2: The Next Step")
                  - "Agenda", "Outline", or "Overview" slides.
                  - "Learning Objectives" slides.
                  - "Thank you", "Questions?", or "Contact Information" slides.
                  - Any slide with almost no content (e.g., just a title and no body, or a single image).
                - For incremental slides (where one slide builds on the previous one), identify the *final* slide in that sequence and include ONLY that final slide in the "pages" array.
                
                Step 3: Output Format (JSON)
                Return ONLY a valid JSON array following this structure. Do not include any other text or markdown fences.

                - **Language:** Your response (especially the "title" fields) **must** be in the primary language detected from the input (e.g., if the text is in German, the titles must be in German).
                
                [
                  {
                    "title": "A descriptive title for this section",
                    "pages": [/* array of page numbers (integers) in this group */]
                  },
                  {
                    "title": "Title for the next section",
                    "pages": [/* ... */]
                  }
                ]
                
                Here is the slide text:
                ${allPagesText}
                `;
                filePayload = null;
            }
            
            let jsonString = await callGeminiWithRetry(prompt, config, model, filePayload);

            if (typeof jsonString === 'string') {
                const firstBrace = jsonString.indexOf('[');
                const firstCurly = jsonString.indexOf('{');
                
                let start = -1;
                
                if (firstBrace === -1 && firstCurly === -1) {
                    console.error("AI response did not contain JSON:", jsonString);
                    throw new Error("AI response did not contain a JSON array or object.");
                }

                if (firstBrace === -1) start = firstCurly;
                else if (firstCurly === -1) start = firstBrace;
                else start = Math.min(firstBrace, firstCurly);

                const lastBrace = jsonString.lastIndexOf(']');
                const lastCurly = jsonString.lastIndexOf('}');
                
                let end = Math.max(lastBrace, lastCurly);

                if (start === -1 || end === -1 || end < start) {
                     console.error("AI response had mismatched delimiters:", jsonString);
                     throw new Error("AI response had mismatched JSON delimiters.");
                }

                jsonString = jsonString.substring(start, end + 1);
            } else {
                return jsonString;
            }

            try {
                return JSON.parse(jsonString);
            } catch (e) {
                console.error("Failed to parse cleaned JSON string:", jsonString);
                throw new Error(`AI returned malformed JSON after cleaning: ${e.message}`);
            }
        }

        /**
         * Processes a single section (group of slides) and returns a Note object and stats.
         * This function is designed to be run in parallel.
         */
        async function processSection(pdfDoc, section, sectionIndex, model, baseTimestamp) {
            if (!section.pages || section.pages.length === 0) {
                // Return null or throw an error to be caught by allSettled
                throw new Error(`Section "${section.title}" has no pages.`);
            }

            // Get options from the DOM
            const slideBySlideMode = document.getElementById('slide-by-slide-checkbox').checked;
            const includeText = document.getElementById('include-text-checkbox').checked;
            
            let finalBackField = '';
            let finalBackContentField = '';
            
            // This text is needed for both modes (or at least for the text field)
            const groupedText = await extractTextForPages(pdfDoc, section.pages);

            if (slideBySlideMode) {
                // --- Slide-by-Slide Mode ---
                // We can even parallelize the *slides within* the group
                const slidePromises = section.pages.map(async (pageNum) => {
                    const imageHtml = await renderImageForPage(pdfDoc, pageNum);
                    const pageText = await extractTextForPage(pdfDoc, pageNum);
                    let annotation = await callGeminiForSlideAnnotation(pageText);
                    
                    let html = imageHtml;
                    if (annotation.trim() && !annotation.includes("")) {
                        html += `<div class="slide-annotation">${annotation}</div>`;
                    }
                    return html;
                });
                
                // Wait for all slides in this group to be processed
                const slideHtmls = await Promise.all(slidePromises);
                finalBackField = slideHtmls.join(''); // Join all slide HTMLs
                finalBackContentField = '';

            } else {
                // --- Default (Group) Mode ---
                // We can run image rendering and AI explanation in parallel
                const imagePromise = renderImagesForPages(pdfDoc, section.pages);
                const explanationPromise = callGeminiForExplanation(groupedText);

                // Wait for both to finish
                const [imageResult, explanation] = await Promise.all([
                    imagePromise,
                    explanationPromise
                ]);

                finalBackField = imageResult.combinedImageHtml;
                finalBackContentField = explanation;
            }

            const orderField = `${baseTimestamp}${sectionIndex.toString().padStart(4, '0')}`;
            const textSearchField = includeText ? groupedText : '';

            const note = model.note([
                orderField,            // Order
                section.title,         // Front
                finalBackField,        // Back
                finalBackContentField, // BackContent
                textSearchField        // Text
            ]);
            
            const stats = [section.title, section.pages.length, section.pages[0]];
            
            // Return both the note and the stats for later
            return { note, stats };
        }


        /**
         * Creates the .apkg file based on the AI's grouping.
         * USES PARALLEL PROCESSING WITH A CONCURRENCY LIMIT
         */
        async function createDeckFromConfig(pdfDoc, jsonConfig) {
            // --- Model and Deck Setup (No Changes) ---
            const m = new Model({
                name: "AI Slides - " + Date.now(),
                id: "1543634829845", 
                flds: [
                    { name: "Order" },      
                    { name: "Front" },      
                    { name: "Back" },       
                    { name: "BackContent" },
                    { name: "Text" },       
                ],
                req: [[0, "all", [0]]],
                tmpls: [{
                    name: "Card 1",
                    qfmt: "{{Front}}",
                    afmt: "{{FrontSide}}<hr id=answer>{{Back}}<br><div class=\"back-content\">{{BackContent}}</div>",
                }],
                css: `
                    .card { font-family: arial; font-size: 20px; text-align: center; color: black; background-color: white; }
                    .back-content { font-size: 16px; display: inline-block; text-align: left; width: 100%; max-width: 700px; line-height: 1.6; margin: 10px auto; padding: 10px; background-color: #f9f9f9; border-radius: 5px; border: 1px solid #eee; }
                    .slide-annotation {
                        font-size: 14px;
                        display: inline-block;
                        text-align: left;
                        width: 100%;
                        max-width: 700px;
                        line-height: 1.5;
                        margin: 5px auto 15px auto;
                        padding: 10px;
                        background-color: #f0f0f0;
                        border-radius: 5px;
                        border: 1px solid #ddd;
                    }
                    h2 { display: inline; }
                    img { max-width: 95%; height: auto; }
                `,
            });

            const deckName = pdfFile.name.replace(/\.[^/.]+$/, "");
            const d = new Deck(Date.now(), deckName);
            const baseTimestamp = new Date().getTime();
            // --- End of Setup ---

            // --- NEW CONCURRENCY LIMIT LOGIC ---
            const totalSections = jsonConfig.length;
            const maxParallelThreads = parseInt(maxParallelInput.value) || 10;
            updateProgress(`Processing ${totalSections} sections (in parallel batches of ${maxParallelThreads})...`, 30);
            
            // 1. Create an array to hold all final results, in order
            const results = new Array(totalSections).fill(null);
            let completedCount = 0;

            // 2. Create a "runner" function that processes one task and updates results
            const runTask = async (index) => {
                const section = jsonConfig[index];
                try {
                    const result = await processSection(pdfDoc, section, index, m, baseTimestamp);
                    results[index] = { status: 'fulfilled', value: result };
                } catch (error) {
                    results[index] = { status: 'rejected', reason: error };
                }
                
                completedCount++;
                const progressPercent = 30 + (completedCount / totalSections) * 65; // 30% to 95%
                updateProgress(`Processing section ${completedCount} of ${totalSections}...`, progressPercent);
            };

            // 3. Create the pool
            const pool = new Set();
            
            for (let i = 0; i < totalSections; i++) {
                const promise = runTask(i);
                pool.add(promise);
                
                // When the promise finishes, remove it from the pool
                promise.then(() => pool.delete(promise));

                // If the pool is full, wait for *one* to finish before adding more
                if (pool.size >= maxParallelThreads) {
                    await Promise.race(pool);
                }
            }
            
            // 4. Wait for all remaining promises in the pool
            await Promise.allSettled(Array.from(pool));
            // --- END NEW CONCURRENCY LOGIC ---


            // --- Process results (this logic is unchanged) ---
            const allNotes = [];
            const cardStats = [];
            let failedSections = 0;

            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    const { note, stats } = result.value;
                    allNotes.push(note);
                    cardStats.push(stats);
                } else {
                    // Log the error and continue
                    const sectionTitle = jsonConfig[index] ? jsonConfig[index].title : `Section ${index + 1}`;
                    console.error(`Failed to process section "${sectionTitle}":`, result.reason);
                    failedSections++;
                }
            });

            // Sort the notes by their 'Order' field before adding.
            allNotes.sort((a, b) => a.fields[0].localeCompare(b.fields[0]));

            // Add all the successful notes to the deck
            allNotes.forEach(note => d.addNote(note));
            
            if (failedSections > 0) {
                // Show a partial error if some sections failed
                const successfulCards = allNotes.length;
                showError(`Warning: ${failedSections} card(s) failed to generate. ${successfulCards} card(s) were created successfully. Check console for details.`);
            }

            updateProgress("Creating .apkg file...", 95);
            const p = new Package();
            p.addDeck(d);
            const apkgArrayBuffer = await p.writeToFile(`${deckName}.apkg`);

            const blob = new Blob([apkgArrayBuffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `${deckName}.apkg`;
            downloadLink.textContent = `Download ${deckName}.apkg`;
            downloadArea.appendChild(downloadLink);

            updateStats(deckName, allNotes.length, cardStats, pdfDoc.numPages);
        }


        /**
         * Renders a single page to an <img> tag string.
         * --- MODIFIED with willReadFrequently ---
         */
        async function renderImageForPage(pdfDoc, pageNum) {
            const compressImages = compressImagesCheckbox.checked;
            const maxResolution = parseInt(maxResolutionInput.value);
            const maxSizeKB = parseInt(maxSizeInput.value);

            const page = await pdfDoc.getPage(pageNum);
            const scale = 2; 
            const viewport = page.getViewport({ scale });

            const canvas = document.createElement('canvas');
            
            // --- FIX 1 ---
            // Add the willReadFrequently hint when getting the context
            const context = canvas.getContext('2d', { willReadFrequently: true });
            
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            // --- FIX 2 ---
            // Also pass the hint to the pdf.js render method
            await page.render({ 
                canvasContext: context, 
                viewport,
                willReadFrequently: true 
            }).promise;

            let imageData = canvas.toDataURL('image/jpeg', 0.9);

            if (compressImages) {
                const response = await fetch(imageData);
                const blob = await response.blob();
                const options = {
                    maxSizeMB: maxSizeKB / 1024,
                    maxWidthOrHeight: maxResolution,
                    useWebWorker: true,
                };
                try {
                    const compressedImage = await imageCompression(blob, options);
                    const reader = new FileReader();
                    reader.readAsDataURL(compressedImage);
                    await new Promise(resolve => reader.onload = resolve);
                    imageData = reader.result;
                } catch (error) {
                    console.error(`Image compression failed for page ${pageNum}:`, error);
                }
            }

            return `<img src="${imageData}">`;
        }

        /**
         * Renders the specified pages into a combined string of <img> tags.
         */
        async function renderImagesForPages(pdfDoc, pagesArray) {
            let combinedImageHtml = '';
            for (const [index, pageNum] of pagesArray.entries()) {
                const imageHtml = await renderImageForPage(pdfDoc, pageNum);
                combinedImageHtml += imageHtml;
                if (index < pagesArray.length - 1) {
                    combinedImageHtml += '<br>'; 
                }
            }
            return { combinedImageHtml, pageNum: pagesArray[0] };
        }

        /**
         * Extracts text from a single page.
         */
        async function extractTextForPage(pdfDoc, pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const textContent = await page.getTextContent();
            return `\n--- Slide (Page ${pageNum}) ---\n` + textContent.items.map(item => item.str).join(' ');
        }


        /**
         * Extracts text from a specific list of pages.
         */
        async function extractTextForPages(pdfDoc, pagesArray) {
            let groupedText = '';
            for (const pageNum of pagesArray) {
                groupedText += await extractTextForPage(pdfDoc, pageNum);
            }
            return groupedText.trim();
        }

        /**
        * Second Gemini call: To explain the content of a *group* of slides.
        */
        async function callGeminiForExplanation(groupedText) { // apiKey removed
            // === PROMPT MODIFIED ===
            const prompt = `
                Task:
                You will be given the text from a set of presentation slides on a specific topic.
                Your task is to provide a clear, comprehensive, and well-structured explanation of the content, as if you were teaching it to a student.
                
                Instructions:
                - **Language:** Respond in the **same language** as the provided slide text.
                - Do not just repeat the slide's bullet points.
                - Elaborate on the concepts, connect the ideas, and provide context.
                - Structure your explanation using simple HTML tags like <p>, <ul>, <li>, and <i>.
                - **For emphasis/bolding, use <b>...</b> tags. DO NOT use markdown asterisks (\`**...**\`).**
                - **Crucially for formulas (Anki/MathJax format):**
                    - For **inline math**, use the format: \\(...\\) (e.g., \\( E = mc^2 \\)).
                    - For **display/block math**, use the format: \\[...\\] (e.g., \\[ \\sum_{i=1}^{n} i = \\frac{n(n+1)}{2} \\]).
                    - **DO NOT** use single dollar signs ($...$) for math.
                - Respond ONLY with the HTML-formatted explanation. Do not add any preamble like "Here is the explanation:", "Sure!", or markdown fences.
                
                Here is the slide text:
                ${groupedText}
            `;
            // === END MODIFICATION ===

            try {
                // This call does not need model selection or file upload, so we use the default params
                return await callGeminiWithRetry(prompt); 
            } catch (error) {
                console.error("Error in explanation call:", error);
                return `<p>(AI explanation failed: ${error.message})</p>`;
            }
        }

        /**
        * Third Gemini call: To annotate a *single* slide, only if needed.
        */
        async function callGeminiForSlideAnnotation(singlePageText) { // apiKey removed
            // === PROMPT MODIFIED ===
            const prompt = `
                Task:
                You will be given the text from a single presentation slide.
                Your task is to provide a brief, clarifying explanation (an "annotation") for this slide *only if it is not self-explanatory*.

                Instructions:
                1.  **Analyze the text:**
                    - If the slide text is just a title, a formula, a diagram description, or a list of keywords, it **needs** an explanation.
                    - If the slide text is already a set of complete sentences or self-explanatory bullet points, it **does not** need an explanation.
                2.  **Response Format (Crucial!):**
                    - If an explanation is needed: Respond ONLY with the explanation, formatted in simple HTML.
                      - Use tags like <p>, <ul>, <li>.
                      - **For bolding, use <b>...</b> tags, NOT markdown asterisks (\`**...**\`).**
                      - Use MathJax format (\\(...\\) and \\[...\\]) for any math. Keep it brief.
                    - If no explanation is needed: Respond ONLY with the exact string "".
                3.  **DO NOT** add any other preamble, markdown, or text.
                4.  **Language:** Respond in the **same language** as the provided slide text.

                Here is the slide text:
                ${singlePageText}
            `;
            // === END MODIFICATION ===

            try {
                 // This call does not need model selection or file upload, so we use the default params
                return await callGeminiWithRetry(prompt);
            } catch (error) {
                console.error("Error in annotation call:", error);
                return `<p>(AI annotation failed: ${error.message})</p>`;
            }
        }


        // --- Utility Functions from Original File ---
        function updateStats(deckName, totalCards, cardStats, totalPages) {
            let statsHTML = `<h3>Stats for ${deckName}</h3>`;
            statsHTML += `<p>Total PDF pages: ${totalPages}</p>`;
            statsHTML += `<p>Total Anki cards created: ${totalCards}</p>`;
            statsHTML += `<h4>Card details (based on AI grouping):</h4>`;
            statsHTML += `<ul>`;
            for (const [title, imageCount, pageNum] of cardStats) {
                statsHTML += `<li>"${title}": ${imageCount} slide${imageCount !== 1 ? 's' : ''} (starting from page ${pageNum})</li>`;
            }
            statsHTML += `</ul>`;
            statsArea.innerHTML = statsHTML;
        }

        var coll = document.getElementsByClassName("collapsible");
        for (let i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                } else {
                    content.style.display = "block";
                }
            });
        }
    </script>
</body>

</html>